# Task Queues Microservice

Микросервис для управления задачами с REST и GraphQL API, асинхронной обработкой событий через RabbitMQ и хранением данных в MongoDB.

## Быстрый старт

1. Установите зависимости:
   ```bash
   npm install
   ```
2. Запустите MongoDB и RabbitMQ через Docker Compose:
   ```bash
   docker-compose up -d
   ```
3. Запустите сервис:
   ```bash
   npm run build && npm start
   ```
4. Импортируйте коллекцию Postman для тестирования API или воспользуйтесь public workspace:
   - Файл: `src/tests/task-queues.postman_collection.json`
   - [Postman workspace](https://web.postman.co/workspace/6f788bd9-1110-4908-bb14-3f5fa91a9ef5)

## REST и GraphQL endpoints
- REST: `http://localhost:3000/tasks`, `http://localhost:3000/health`
- GraphQL: `http://localhost:4000/graphql`

## Безопасность
- Валидация и санитайзинг входных данных (Fastify schema, sanitize-html)
- Ограничения по длине строк, XSS-защита

## Структура проекта
```
/src
  /controllers      # REST и GraphQL контроллеры
  /services         # Бизнес-логика, работа с БД и RabbitMQ
  /models           # Модели данных (MongoDB)
  /schemas          # Схемы валидации Fastify
  /graphql          # GraphQL-схемы, резолверы, сгенерированные типы
  /routes           # REST-роуты
  /tests            # Тесты и коллекции Postman
index.ts            # Точка входа
codegen.yml         # Конфиг для @graphql-codegen/cli
```

## Окружение
- Node.js, TypeScript, Fastify
- MongoDB
- RabbitMQ (Direct Exchange)
- Apollo Server (GraphQL)
- @graphql-codegen/cli

## Архитектура RabbitMQ
Сервис использует RabbitMQ для обмена событиями между микросервисами. Для публикации событий применяется схема Direct Exchange:

- **Exchange:** `task.exchange`
- **Очереди:** `task.actions`
- **Routing key:** `task.action`

**Почему выбран Direct Exchange:**
Direct Exchange позволяет точно маршрутизировать сообщения по routing key. Это удобно, когда разные микросервисы интересуются только определёнными типами событий (например, только созданием или только обновлением задач). Такой подход обеспечивает гибкость и масштабируемость интеграций, а также снижает нагрузку на подписчиков, которым не нужно фильтровать неинтересные события.

## План разработки
- [PLAN.md](./PLAN.md)

## Взаимодействие с другими микросервисами
Сервис может взаимодействовать с другими микросервисами через RabbitMQ, публикуя события о создании, обновлении и удалении задач. Другие сервисы могут подписываться на эти события для синхронизации данных, триггеров уведомлений или запуска фоновых процессов. Также возможна интеграция через REST и GraphQL API для прямого обмена данными.

## Возможные улучшения
- Ввести роли пользователей и разграничение прав (в рамках интеграции с другим микросервисами)
- Реализовать трекинг истории изменений задач
- Добавить поддержку WebSocket для real-time обновлений (в рамках интеграции с другим микросервисами)
- Вынести схему событий RabbitMQ в отдельный контракт
- Покрыть сервис интеграционными тестами

## Использование LLM и автогенерация кода

В проекте части кода были сгенерированы с помощью LLM (Large Language Model, например, GPT):

- **GraphQL-схемы и резолверы:** Автоматически сгенерированы на основе модели данных и бизнес-логики. Логика: предоставляют типизированный API для задач, поддерживают фильтрацию, создание и обновление задач, публикуют события в RabbitMQ.
- **REST-контроллеры и сервисы:** Сгенерированы шаблоны CRUD-операций, валидация, санитайзинг, публикация событий. Логика: реализуют стандартные REST-эндпоинты для работы с задачами, обеспечивают безопасность и корректность данных.
- **RabbitMQ publisher/consumer:** Сгенерированы обработчики публикации и потребления событий. Логика: отправка событий о задачах в очередь и логирование полученных событий в человекочитаемом виде.
- **Тесты и коллекция Postman:** Сгенерированы примеры запросов и тестов для проверки API. Логика: автоматизация проверки корректности работы REST и GraphQL-интерфейсов.

Все сгенерированные фрагменты были вручную проверены, доработаны и интегрированы в общую архитектуру проекта.